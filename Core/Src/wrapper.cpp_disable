#include <CRSLib/executor.hpp>
#include <CRSLib/Can/STM32f1/can_manager.hpp>
#include <CRSLib/Can/STM32f1/filter_manager.hpp>

#include <can_sample.hpp>

namespace Chibarobo2022
{
	CRSLib::Executor<void () noexcept, 100> executor{};
}

using namespace CRSLib;
using namespace Chibarobo2022;
using namespace CRSLib::Can;
using namespace CRSLib::Can::STM32f1;


extern "C"
{
	void wrapper_cpp(CAN_HandleTypeDef *const hcan) noexcept
	{

		CanManager can_manager{hcan};

		FilterManager::dynamic_initialize();

		FilterManager::ConfigFilterArg<FilterWidth::bit32, FilterMode::mask> filter_arg
		{
			{
				{
					.id = {0x40, 0x0, false, false},
					.mask = {max_std_id, max_ext_id, true, true}
				}
			},
			FifoIndex::fifo0,
			0,
			true
		};

		FilterManager::config_filter_bank(15, filter_arg);

		while(true)
		{
			receiver.receive(can_manager.letterbox0, executor);
			receiver.receive(can_manager.letterbox1, executor);
			transmitter.transmit(can_manager.pillarbox);
		}
	}
}

//#include <CRSLib/Can/STM32f1/hal_can.hpp>
//
//#include <CRSLib/can/CommonAmongMpu/transmitter.hpp>
//
//using namespace CRSLib::IntegerTypes;
//
//enum class HogeCommand : u32
//{
//	hoge1,
//
//	n
//};
//
//namespace CRSLib::Can
//{
//	template<>
//	struct TxIdImplInjector<HogeCommand::hoge1>
//	{
//		static constexpr size_t queue_size(){return 1;};
//	};
//}
//
//extern "C"
//{
//	void wrapper_cpp(CAN_HandleTypeDef *const) noexcept
//	{
////		CRSLib::Can::Transmitter<HogeCommand> transmitter{(u32)0x40};
//		static_assert(CRSLib::Can::Implement::IdImplInjectorBase<CRSLib::Can::TxIdImplInjector<HogeCommand::hoge1>>);
//	}
//}
